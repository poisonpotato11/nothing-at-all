<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Game</title>
    <script src="https://threejs.org/build/three.js"></script>
</head>
<body>
    <script>
        // Set up the scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a red player character
        const geometryPlayer = new THREE.BoxGeometry();
        const materialPlayer = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color
        const player = new THREE.Mesh(geometryPlayer, materialPlayer);
        scene.add(player);

        // Create procedural terrain
        const terrainSize = 30;
        const terrainResolution = 10;
        const terrain = new THREE.Mesh(generateTerrain(terrainSize, terrainResolution), new THREE.MeshBasicMaterial({ color: 0x8B4513 }));
        scene.add(terrain);

        // Set up camera position
        camera.position.y = 5;
        camera.lookAt(player.position);

        // Handle window resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });

        // Handle player movement
        const playerSpeed = 0.1;
        const playerMovement = { left: false, right: false, forward: false, backward: false };

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'a':
                    playerMovement.left = true;
                    break;
                case 'd':
                    playerMovement.right = true;
                    break;
                case 'w':
                    playerMovement.forward = true;
                    break;
                case 's':
                    playerMovement.backward = true;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'a':
                    playerMovement.left = false;
                    break;
                case 'd':
                    playerMovement.right = false;
                    break;
                case 'w':
                    playerMovement.forward = false;
                    break;
                case 's':
                    playerMovement.backward = false;
                    break;
            }
        });

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);

            // Update player position based on movement
            if (playerMovement.left) player.position.x -= playerSpeed;
            if (playerMovement.right) player.position.x += playerSpeed;
            if (playerMovement.forward) player.position.z -= playerSpeed;
            if (playerMovement.backward) player.position.z += playerSpeed;

            // Update camera position to follow the player
            camera.position.x += (player.position.x - camera.position.x) * 0.05;
            camera.position.z += (player.position.z + 10 - camera.position.z) * 0.05;

            camera.lookAt(player.position);

            renderer.render(scene, camera);
        };

        animate();

        // Function to generate procedural terrain
        function generateTerrain(size, resolution) {
            const geometry = new THREE.Geometry();

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const x = i - size / 2;
                    const y = 0;
                    const z = j - size / 2;

                    // Simple procedural height generation
                    const height = Math.sin(i / resolution) * Math.cos(j / resolution) * 5;

                    geometry.vertices.push(new THREE.Vector3(x, height, z));
                }
            }

            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size - 1; j++) {
                    const a = i + j * size;
                    const b = (i + 1) + j * size;
                    const c = i + (j + 1) * size;
                    const d = (i + 1) + (j + 1) * size;

                    geometry.faces.push(new THREE.Face3(a, b, d));
                    geometry.faces.push(new THREE.Face3(a, d, c));
                }
            }

            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            return geometry;
        }
    </script>
</body>
</html>
